%====================================================================
%     Muse
%     Design & Implementation
%
% (C) 2005 Copyright: Werner Schweer and Others
%====================================================================

%----------------------------------------------------------
%     Setup
%----------------------------------------------------------

%\showframe
%\showsetups
\usemodule[chart]
\setupcolors[state=start]
\setupbodyfont[Palatino]
\language[en]
\enableregime[il1]

\startuseMPgraphic{FunnyFrame}
      picture p; numeric o; path a, b; pair c;
      p := textext.rt(\MPstring{FunnyFrame});
      o := BodyFontSize;
      a := unitsquare xyscaled(OverlayWidth,OverlayHeight);
      p := p shifted (20, OverlayHeight-ypart center p);
      drawoptions (withpen pencircle scaled 1pt withcolor .625red);
      b := a superellipsed .95;
      fill b withcolor .85white; draw b;
      b := (boundingbox p) superellipsed .95;
      fill b withcolor .85white; draw b;
      draw p withcolor black;
      setbounds currentpicture to a;
    \stopuseMPgraphic

\defineoverlay[FunnyFrame][\useMPgraphic{FunnyFrame}]
\defineframedtext[FunnyText][frame=off,background=FunnyFrame]
\def\StartFrame{\startFunnyText}
\def\StopFrame{\stopFunnyText}
\def\FrameTitle#1%
 {\setMPtext{FunnyFrame}{\hbox spread 1em{\hss\strut#1\hss}}}
\setMPtext{FunnyFrame}{}


\define\M{Muse}
\define[1]\Index{{\it #1}\marginpar{#1}\index{#1}}

\defineindenting[Cmdi][text=,separator=,width=fit,distance=1em]

\define[1]\Cmd{
  \Cmdi
  \framed[
     background=color,
     width=fit,
     align=right,
     backgroundcolor=lightgray,
     framecolor=blue]
     {\tt\space #1}}

\define[2]\CCmd{
  \Cmdi
  \framed[
     background=color,
     width=broad,
     align=right,
     backgroundcolor=lightgray,
     framecolor=blue]
     {\vbox{\hbox{\tt\space #1}\hbox{\tt\space #2}}}}


%\define\startdescription{\startpacked}
\define\startdescription{}
%\define\stopdescription{\stoppacked}
\define\stopdescription{}

\define[1]\Fig{\hbox{\externalfigure[pics/#1]}}

\define[2]\Screen{
      \placefigure[here][fig:#1]{#2}{\externalfigure[pics/#1][scale=1600]}
      }
\define[1]\Noten{
      \blank[line]
      {\externalfigure[pics/#1][scale=700]}
      \blank[line]
      }

\definedescription[Option][
      location=left,
      headstyle=bold,
      width=4em,
      before={\startnarrower[left]\setupblank[0pt]},
      after={\stopnarrower\setupblank}]

\definedescription[Filetype][
      location=left,
      headstyle=bold,
      width=4em,
      before={\startnarrower[left]\setupblank[0pt]},
      after={\stopnarrower\setupblank}]

\definedescription[FileList][
      location=left,
      headstyle=bold,
      width=7em,
      before={\startnarrower[left]\setupblank[0pt]},
      after={\stopnarrower\setupblank}]

\definedescription[Input][
      location=left,
      headstyle=bold,
      width=9em,
      before={\startnarrower[left]\setupblank[0pt]},
      after={\stopnarrower\setupblank}]

\definedescription[InputN][
      location=left,
      headstyle=bold,
      width=6em,
      before={\startnarrower[left]\setupblank[0pt]},
      after={\stopnarrower\setupblank}]

\define[2]\Figure{
      \placefigure
         [#1][fig:#2]{}
         {\externalfigure[pics/#2]}
         }

\define[1]\Menu{
      \placefigure[right][fig:#1]{}
         {\externalfigure[pics/#1][scale=2000]}
         }

\definedescription[Opt][location=hanging,headstyle=bold,width=broad]

\setuptyping[before=\blank\startbackground, after=\stopbackground\blank] % source code with background
\setupwhitespace[medium]

%----------------------------------------------------------
%     Body
%----------------------------------------------------------

\starttext
   \language[en]
   \mainlanguage[en]
   \startstandardmakeup[doublesided=no]
      \definebodyfont[10pt,11pt,12pt][rm][tfe=Regular at 48pt]
      \tfe\setupinterlinespace
      \hfill \color[red]{\M}\par
      \hfill \color[blue]{Design \&}\par
      \hfill \color[blue]{Implementation}\par
      \vfill
      \definebodyfont[10pt,11pt,12pt][rm][tfb=Regular at 24pt]
      \tfb\setupinterlinespace
      \hfill Version 1.0\par
%%      \hfill April 2005\par
%%      \hfill Werner Schweer
      \stopstandardmakeup

   \startstandardmakeup[page=no]
      \vfill
      \M\ is hosted on SourceForge:\par
      \type{http://lmuse.sourceforge.net/}
      \blank[line]
      This document was created using \pdfTeX\ and the
      \ConTeXt\ macro package.
      \blank[line]
      \copyright 2005 Werner Schweer and Others
      \stopstandardmakeup

   \completecontent

%%
%%=======================================================================
%%    File Formats
%%=======================================================================
%%

\chapter{File Formats}
      \section{Instrument Definition Files}

      \M\ Instrument Definition Files are used to describe the
      properties of external midi instruments.

      IDF-Files have the file extension \type{*.idf} \index{idf} and
      they are searched in the \M\ "instruments" subdirectory (which is on
      my system \type{/usr/share/muse-1.0/instruments}.

      An instrument\index{Instrument definition} is a property of the
      midi ouput channel \index{Midi output port}.
      All found instrument definitions are presented by MusE
      in the Instrument pulldown menu of the midi output port.

      Example of an instrument definition file:
      \blank
\starttyping
<?xml version="1.0"?>
<muse version="1.0">
  <MidiInstrument name="GM">
    <Init>
      ...MusE event list which initializes instrument
      </Init>
    <PatchGroup name="Piano">
       <Patch name="Grand Piano" prog="0"/>
       <Patch name="Bright Piano" prog="1"/>
       ...
      </PatchGroup>
    <PatchGroup name="Bass">
      <Patch name="Acoustic Bass" prog="32"/>
      <Patch name="Fingered Bass" prog="33"/>
      </PatchGroup>
    ...
    <Controller name="Brightness">
      <n>0x4a</n>
      <min>0</min>
      <max>127</max>
      <init>0</init>
      </Controller>
    ...
    </MidiInstrument>
  </muse>
\stoptyping
      \blank

      PatchGroups\index{PatchGroups} are not mandatory; its valid to write:

      \blank
\starttyping
<MidiInstrument name="GM">
  <Patch name="Grand Piano" prog="0"/>
  <Patch name="Bright Piano" prog="1"/>
  <Patch name="Acoustic Bass" prog="32"/>
  <Patch name="Fingered Bass" prog="33"/>
  ...
  </MidiInstrument>
\stoptyping
      \blank

      An instrument definition file should only define one
      instrument.

      The "prog" parameter in a "Patch" is mandatory. Missing
      "hbank" or "lbank" are treated as "don't care".
      Missing "drum" is treated as drum="0".

      A XG-Patch looks like this:

      \blank
      \starttyping
<Patch name="Electro" drum="1" hbank="127"
   lbank="0" prog="24"/>
      \stoptyping
      \blank

      A patch can be associated with a "mode" with one of:
            \blank[medium]
            \Option{1}  - GM\par
            \Option{2}  - GS\par
            \Option{4}  - XG\par
            \blank[big]

      Example:

      \blank
      \starttyping
<Patch name="Electro" mode="4" drum="1" hbank="127"
   lbank="0" prog="24"/>
      \stoptyping
      \blank

      Mode id's can be ore'd together for patches which are valid
      for more than one mode:

      \blank
      \starttyping
<Patch name="Grand Piano" mode=7" hbank="0" lbank="0" prog="0"/>
      \stoptyping
      \blank

      example for MusE event (Sysex "XG-On"):

      \blank
      \starttyping
<event tick="0" type="5" datalen="7">
  43 10 4c 00 00 7e 00
  </event>
      \stoptyping
      \blank

      \type{<Init> ... </Init>} part can be omitted


      Controller\index{Controller} have the following properties:

      \starttabulate
      \NC name:\NC
             arbitrary unique (short) string describing the controller\NC\NR
      \NC n:\NC
            controller number, defines also the controller type:\par
            values from \type{0x0 - 0x7f} are 7Bit controller\par
            values from \type{0x1000 - 0x1ffff} are 14 bit controller with
               MSB/LSB value pairs\par
            values from \type{0x20000 - 0x2ffff} are RPN's\par
            values from \type{0x30000 - 0x3ffff} are NRPN's
            \NC\NR
      \NC min:\NC minimum value for controller\NC\NR
      \NC max:\NC maximum value for controller\NC\NR
      \NC init:\NC
            reset value for controller; when controller value is
            undefined after instrument reset, use the ''undefined''
            value \type{0x10000}
            \NC\NR
      \stoptabulate

      the min/max/init values can be ommited

%%
%%=======================================================================
%%    Midi Plugins
%%=======================================================================
%%
\chapter{Plugins}
      \section{Midi Plugins}


      Midi plugins have the file extension \type{*.so} and they are
      searched in the \M\ "\type{midiplugins}" subdirectory (which is on
      my system \type{/usr/lib/muse-1.0/midiplugins}.

%
%-----------------------------------
%    Midi Filter
%-----------------------------------
%
      \subsection{Midi Filter}

      Example for an midi plugin which does essentially nothing:

      First define your custom \type{Filter} class with \type{Mempi}
      as base class.

\starttyping
#include "../libmidiplugin/mempi.h"

class Filter : public Mempi {
      virtual void process(unsigned, unsigned,
         MPEventList*, MPEventList*);

   public:
      Filter(const char* name, const MempiHost*);
      ~Filter() {}
      virtual bool init() { return false; }
      };

Filter::Filter(const char* name, const MempiHost* h)
   : Mempi(name, h)
      {
      }
\stoptyping

      Now comes the main \type{Mempi} function you have to implement:
      \type{process()} which has two parameters, an midi event input
      list and an midi event output list. The example code simply
      copies all events from the input list to the output list.

\starttyping
void Filter::process(unsigned, unsigned, MPEventList* il,
   MPEventList* ol)
      {
      for (iMPEvent i = il->begin(); i != il->end(); ++i) {
            ol->insert(*i);
            }
      }
\stoptyping

      When loading the plugin, the \type{Mempi} Host looks for
      the symbol \type{mempi_descriptor}. This function returns a
      pointer to the plugin class description you have to fill in.

\starttyping
static Mempi* instantiate(const char* name, const MempiHost* h)
      {
      return new Filter(name, h);
      }

extern "C" {
      static MEMPI descriptor = {
            "Filter",
            "MusE Zero Filter",
            "0.1",                  // filter version string
            MEMPI_FILTER,           // plugin type
            MEMPI_MAJOR_VERSION, MEMPI_MINOR_VERSION,
            instantiate
            };

      const MEMPI* mempi_descriptor() { return &descriptor; }
      }
\stoptyping


%
%-----------------------------------
%    GUI interface
%-----------------------------------
%
\subsection{GUI interface}
      Every midi plugin can implement a native graphical user
      interface (GUI). For this you have to overload five
      virtual functions.

\starttyping
   virtual bool hasGui() const { return true; }
\stoptyping
      This function informs the host whether there is an GUI or not.

\starttyping
   virtual bool guiVisible() const { return gui->isVisible(); }
\stoptyping
      This fuction returns \type{true} if your GUI is visible.

\starttyping
   virtual void showGui(bool val) const { gui->setShown(val); }
\stoptyping
      This function shows or hides the GUI.

      There are two helper functions the plugin host uses to save
      and restore the GUI geometry across sessions:

\starttyping
   virtual void getGeometry(int* x, int* y, int* w, int* h) const;
   virtual void setGeometry(int, int, int, int);
\stoptyping

%
%-----------------------------------
%    Persistent Parameters
%-----------------------------------
%
\subsection{Persistent Parameters}

      The plugin host can save and restore plugin parameter across
      sessions. When the host saves his session status, he calls
      the midi plugin function:

\starttyping
   virtual void getInitData(int* len, const unsigned char**p) const;
\stoptyping

      You can overload this function to return a pointer to your
      session data and the len of the data block.

      When the session is restored, the host calls

\starttyping
   virtual void setInitData(int len, const unsigned char* p);
\stoptyping

      which you can use to restore the last plugin state.
%
%-----------------------------------
%    Host Access Functions
%-----------------------------------
%

\subsection{Host Access Functions}

      The plugin host supplies some functions which are
      accessible through the \type{MempiHost*} in the
      \type{Mempi} interface.

      The host supplies the following functions:

\starttyping
      int division() const;
\stoptyping
      \index{division()}
      returns the midi \type{division} value which gives  the number
      of midi ticks per midi beat, typically 384.

\starttyping
      int tempo(unsigned tick) const;
\stoptyping
      \index{tempo()}
      returns the midi tempo value.

\starttyping
      unsigned tick2frame(unsigned tick) const;
\stoptyping
      \index{tick2frame()}
      This function converts a transport position given in midi ticks
      to a audio frame position.

\starttyping
      unsigned frame2tick(unsigned frame) const;
\stoptyping
      \index{frame2tick()}
      This function converts a transport position given in audio frames
      to midi ticks.

\starttyping
      void bar(int tick, int* bar, int* beat, unsigned* rest) const;
\stoptyping
      \index{bar()}
      This function return bar/beat and a tick rest for a given
      tick position.

\starttyping
      unsigned bar2tick(int bar, int beat, int tick) const;
\stoptyping
      This is the opposite to the \type{bar} function. It converts
      a time position given in bar/beat/tick into a midi tick value.

%
%-----------------------------------
%    Midi Synthesizer
%-----------------------------------
%
\subsection{Midi Synthesizer}
      As an example for a midi synthesizer plugin we use a midi
      metronome.

      Lets start with the class definition:

\starttyping
#include "../libmidiplugin/mempi.h"

//---------------------------------------------------------
//   metronom - simple midi metronom
//---------------------------------------------------------

class Metronom : public Mempi {

   protected:
      struct InitData {
            char measureNote;
            char measureVelo;
            char beatNote;
            char beatVelo;
            } data;
      MetronomGui* gui;
      friend class MetronomGui;

      unsigned int nextTick;
      unsigned int lastTo;

      virtual void process(unsigned, unsigned, MPEventList*,
         MPEventList*);

   public:
      Metronom(const char* name, const MempiHost*);
      ~Metronom();
      virtual bool init();

      virtual bool hasGui() const      { return true;             }
      virtual bool guiVisible() const  { return gui->isVisible(); }
      virtual void showGui(bool val)   { gui->setShown(val);      }
      virtual void getGeometry(int* x, int* y, int* w, int* h) const;
      virtual void setGeometry(int, int, int, int);

      virtual void getInitData(int*, const unsigned char**) const;
      virtual void setInitData(int, const unsigned char*);
      };
\stoptyping

%
%-----------------------------------
%    MESS interface
%-----------------------------------
%
\chapter {The M.E.S.S (MusE Experimental Software Synthesizer) API}

    M.E.S.S.\index{M.E.S.S.} stands for MusE Experimental Soft Synth and is
    an API/interface (like DSSI) to enable programmers to easily create their
    own softsynths.

    The interface for a M.E.S.S.-synth consists of two classes, the Mess and
    MessGui. In short, the framework provides the Mess (the synth) midi data
    (notes, controllers and sysexes) and methods that handle the IPC between
    the gui and the synth, so the programmer can focus on DSP-issues instead.

    The interface for the synth is specified in the mess.h file in the libsynti
    directory. The interface for the MessGui is specified in the gui.h file.

\starttyping
//---------------------------------------------------------
//  Mess
//    MusE experimental software synth
//    Instance virtual interface class
//---------------------------------------------------------

class Mess {
      MessP* d;

      int _sampleRate;
      int _channels;                // 1 - mono,  2 - stereo

   public:
      Mess(int channels);
      virtual ~Mess();

      int channels() const       { return _channels;   }
      int sampleRate() const     { return _sampleRate; }
      void setSampleRate(int r)  { _sampleRate = r;    }

      virtual void process(float** data, int offset, int len) = 0;

      // the synti has to (re-)implement processEvent() or provide
      // some of the next three functions:

      virtual bool processEvent(const MidiEvent&);
      virtual bool setController(int, int, int) { return false; }
      virtual bool playNote(int, int, int) { return false; }
	virtual bool sysex(int, const unsigned char*) { return false; }

      virtual void getInitData(int*, const unsigned char**) const {}
      virtual int getControllerInfo(int, const char**, int*, int*, int*) const {return 0;}
      virtual const char* getPatchName(int, int, int) const { return "?"; }
      virtual const MidiPatch* getPatchInfo(int, const MidiPatch*) const { return 0; }

      // synthesizer -> host communication
      void sendEvent(MidiEvent);  // called from synti
      MidiEvent receiveEvent();   // called from host
      int eventsPending() const;

      // GUI interface routines
      virtual bool hasGui() const { return false; }
      virtual bool guiVisible() const { return false; }
      virtual void showGui(bool) {}
      virtual void getGeometry(int* x, int* y, int* w, int* h) const;
      virtual void setGeometry(int, int, int, int) {}
      };
\stoptyping

\section{Overview of virtual member functions}
      This is a short description of the virtual functions in the Mess-class:
\subsection{process}
\starttyping
virtual void process(float** data, int offset, int len) = 0;
\stoptyping
      This is where the audio processing takes place. The Mess is called with a float array, and
      it's up to the programmer to fill it with data beginning at data[offset] to data[offset+len].

\subsection{processEvent}
      There are two ways to go when it comes to how midi data is fed into the Mess. You can either
      implement processEvent and manage the different event types (controllers, sysexes and notes)
      or implement one or more of the setController, playNote and sysex functions.


      Note that overriding processEvent results in setController, playNote and sysex
      not being called!

\subsection{setController, playNote, sysex}
      The setController, playNote and sysex functions should return false if the event was
      processed, true if the synth was busy.

\starttyping
virtual bool setController(int channel, int controller_no, int value)

virtual bool playNote(int channel, int pitch, int velo)

virtual bool sysex(int length, const unsigned char* data)
\stoptyping

\subsection{getInitData}
      MusE provides an interface for storing the state of the synth in the project file.
      getInitData is called when the project is saved, and provides a pointer to a data
      block where you store the data which will recreate the synths current state when
      the project is reopened.
\starttyping
virtual void getInitData(int* nrofchars, const unsigned char** data) const {}
\stoptyping

\subsection{getControllerInfo}
      getControllerInfo is called when the Mess is instantiated, and this is where
      you tell MusE which controllers the Mess supports. The function is called
      repeteadly: just fill in the values for the controller and return the index
      you want to be sent next time. Return 0 when you've given MusE information about
      all controllers your Mess supports.

      As you can see, the necessary parameters are an index (used internally), a name
      for the controller, an int describing the actual controller number (f.ex. 91 for
      reverb), and finally min and max values for the controller.

\starttyping
virtual int getControllerInfo(int index,
                              const char** name,
                              int* controller,
                              int* min,
                              int* max) const
\stoptyping

\subsection{hasGui}
      hasGui is called when the Mess is instantiated, and tells MusE if the synth has
      a gui or not.
\starttyping
virtual bool hasGui() const;
\stoptyping

\subsection{showGui}
showGui is called from MusE when the gui is supposed to be visible
\starttyping
virtual void showGui(bool show);
\stoptyping

\subsection{getPatchName, getPatchInfo}
      getPatchName and getPatchInfo are used to give MusE information about patches,
      which can be selected in the track inspector.

      The getPatchName function specifies three parameters to be passed: channel,
      program, and a third that is unused. It is the responsibility for the synth
      to return the patchname for the particular channel and a program.

\starttyping
virtual const char* SimpleSynth::getPatchName(int channel, int program, int unused) const
\stoptyping

      getPatchInfo is called repeatedly until the synth returns 0. The synth must
      send information back in a MidiPatch struct. The MidiPatch parameter sent
      contains information on the last MidiPatch that was sent from the synth
      (a null pointer on first call).

\starttyping
virtual const MidiPatch* getPatchInfo(int channel,
                                      const MidiPatch* previouspatch)
                                      const;

struct MidiPatch {
      signed char type;   // 1 - GM  2 - GS  4 - XG
      signed char hbank, lbank, prog;
      const char* name;
      };
\stoptyping


\subsection{Descriptor}
      Since the synths are built as shared libraries, you need to specify a descriptor
      for your MESS. They look something like this: (example taken from SimpleSynth/SimpleDrums)

\starttyping
static Mess* instantiate(int sr, QWidget*, const char* name)
 {
  printf("SimpleSynth sampleRate %d\n", sr);
  SimpleSynth* synth = new SimpleSynth(sr);
  if (!synth->init(name)) {
    delete synth;
    synth = 0;
    }
  return synth;
 }
extern "C"
 {
  static MESS descriptor = {
    "SimpleSynth",
    "Mathias Lundgren (lunar_shuttle@users.sf.net)",
    "0.1", //Version string
    MESS_MAJOR_VERSION, MESS_MINOR_VERSION,
    instantiate,
  };
  const MESS* mess_descriptor() { return &descriptor; }
 }
\stoptyping

\section{MessGui}
      For the Gui, there's really only one method that is interesting, processEvent.
      processEvent in the gui is called whenever the synth sends it a midiEvent, which
      it does with send(MidiEvent ).
      Since this is the only method of communicating the gui can send midimessages
      to the synth via sendEvent, sendController and sendSysex calls.
\starttyping
virtual void processEvent(const MidiPlayEvent&) {};
\stoptyping


\completeindex
\stoptext
